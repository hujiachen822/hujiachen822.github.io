{"meta":{"title":"Hujiachen's Blog","subtitle":null,"description":null,"author":"胡佳晨","url":"http://hujiachen822.github.io"},"pages":[],"posts":[{"title":"算法：二叉树数据结构","slug":"binaryTree","date":"2018-01-18T07:07:03.416Z","updated":"2018-01-18T07:08:35.087Z","comments":true,"path":"2018/01/18/binaryTree/","link":"","permalink":"http://hujiachen822.github.io/2018/01/18/binaryTree/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260/*** * 二叉树数据模型 * @author Hjc * * @param &lt;Key&gt; * @param &lt;Value&gt; */public class binaryTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private class Node &#123; private Key key;// 键 private Value value;// 值 private Node left, right;// 左链接，右链接 private int N;// 个数 public Node(Key key, Value value, int N) &#123; this.key = key; this.value = value; this.N = N; &#125; &#125; /** * 获取数量 * @return */ public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) &#123; return 0; &#125; else &#123; return x.N; &#125; &#125; /** * 获取值 * @param key 键 * @return */ public Value get(Key key) &#123; return get(root, key); &#125; private Value get(Node x, Key key) &#123; if (x == null) &#123; return null; &#125; int tag = key.compareTo(x.key); if (tag &gt; 0) &#123; return get(x.right, key); &#125; else if (tag &lt; 0) &#123; return get(x.left, key); &#125; else &#123; return x.value; &#125; &#125;; /** * 插入键值 * @param key 键 * @param key 值 */ public void put(Key key, Value value) &#123; root = put(root, key, value); &#125;; private Node put(Node x, Key key, Value value) &#123; if (x == null) &#123; return new Node(key, value, 1); &#125; int tag = key.compareTo(x.key); if (tag &gt; 0) &#123; x.right = put(x.right, key, value); &#125; else if (tag &lt; 0) &#123; x.left = put(x.left, key, value); &#125; else &#123; x.value = value; &#125; x.N = size(x.left) + size(x.right) + 1; return x; &#125; /** * 获取最小的键 * @return */ public Key min() &#123; return min(root).key; &#125; private Node min(Node x) &#123; if (x.left == null) &#123; return x; &#125; return min(x.left); &#125; /** * 获取最大的键 * @return */ public Key max() &#123; return max(root).key; &#125; private Node max(Node x) &#123; if (x.right == null) &#123; return x; &#125; return max(x.right); &#125; /** * 根据位置查询键 * @param i 位置 * @return */ public Key select(int i) &#123; return select(root, i).key; &#125; private Node select(Node x, int k) &#123; if (x == null) &#123; return null; &#125; int t = size(x.left); if (t &gt; k) &#123; return select(x.left, k); &#125; else if (t &lt; k) &#123; return select(x.right, k - t - 1); &#125; else &#123; return x; &#125; &#125; /** * 根据键来获取位置 * @param key 键 * @return */ public int rank(Key key) &#123; return rank(key, root); &#125; private int rank(Key key, Node x) &#123; if (x == null) &#123; return 0; &#125; int tag = key.compareTo(x.key); if (tag &lt; 0) &#123; return rank(key, x.left); &#125; else if (tag &gt; 0) &#123; return 1 + size(x.left) + rank(key, x.right); &#125; else &#123; return size(x.left); &#125; &#125; /** * 删除最小的 */ public void deleteMin() &#123; deleteMin(root); &#125; private Node deleteMin(Node x) &#123; if (x == null) &#123; return x.right; &#125; x.left = deleteMin(x.left); x.N = size(x.left) + size(x.right) + 1; return x; &#125; /** * 删除指定键 * @param key 键 */ public void delete(Key key) &#123; delete(root, key); &#125; public Node delete(Node x, Key key) &#123; if (x == null) &#123; return null; &#125; int tag = key.compareTo(x.key); if (tag &lt; 0) &#123; x.left = delete(x.left, key); &#125; else if (tag &gt; 0) &#123; x.right = delete(x.right, key); &#125; else &#123; if (x.right == null) &#123; return x.left; &#125; if (x.left == null) &#123; return x.right; &#125; Node t = x; x = min(t.right); x.right = deleteMin(t.right); x.left = t.left; &#125; x.N = size(x.left) + size(x.right) + 1; return x; &#125; /** * 输出 * @param x */ public void print(Node x) &#123; if (x == null) &#123; return; &#125; print(x.left); System.out.println(x.key); print(x.right); &#125; public Key floor(Key key) &#123; Node x = floor(root, key); if (x == null) &#123; return null; &#125; return x.key; &#125; private Node floor(Node x, Key key) &#123; if (x == null) &#123; return null; &#125; int tag = key.compareTo(x.key); if (tag == 0) &#123; return x; &#125; if (tag &lt; 0) &#123; return floor(x.left, key); &#125; Node t = floor(x.right, key); if (t != null) &#123; return t; &#125; else return x; &#125;&#125;","categories":[],"tags":[]},{"title":"算法：查找学习笔记","slug":"search","date":"2018-01-17T02:06:26.276Z","updated":"2018-01-17T07:13:11.422Z","comments":true,"path":"2018/01/17/search/","link":"","permalink":"http://hujiachen822.github.io/2018/01/17/search/","excerpt":"","text":"&nbsp;判断字符串中那个单词出现的次数最多12345678910111213141516171819202122232425262728/** * 判断字符串中那个单词出现的次数最多(适用于小数据集) * @param string 一句用空格分开的话 * @return */public Object getMaxKey(String string) &#123; Object maxKey = null; int maxSize=0; Map&lt;Object, Integer&gt; sizeMap = new HashMap&lt;Object, Integer&gt;(); String[] myString =string.split(&quot; &quot;); maxKey=myString[0]; for (String word : myString) &#123; if (sizeMap.containsKey(word)) &#123; sizeMap.put(word, sizeMap.get(word) + 1); &#125; else &#123; sizeMap.put(word, 1); &#125; &#125; for (Object key : sizeMap.keySet()) &#123; if (sizeMap.get(key) &gt; sizeMap.get(maxKey)) &#123; maxKey = key; maxSize=sizeMap.get(key); &#125; &#125; return maxKey+&quot;,&quot;+maxSize+&quot;次&quot;;&#125; &nbsp;二分法查找123456789101112131415161718192021222324/** * 二分法查找 * @param key 需要查找的key * @param map 有序的集合 * @param start 查找起始位置 * @param end 查找终止位置 * @return */public Integer binarySearch(int key, LinkedHashMap&lt;Integer, Integer&gt; map, int start, int end) &#123; if (start &gt; end) &#123; return map.get(start); &#125; int middle = start + (start + end) / 2; int tag = map.get(key).compareTo(map.get(middle)); if (tag &gt; 0) &#123; return binarySearch(key,map,start,middle-1); &#125; else if (tag &lt; 0) &#123; return binarySearch(key,map,middle-1,end); &#125;else&#123; return middle; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"sort","date":"2018-01-15T06:17:49.163Z","updated":"2018-01-18T07:08:44.815Z","comments":true,"path":"2018/01/15/sort/","link":"","permalink":"http://hujiachen822.github.io/2018/01/15/sort/","excerpt":"","text":"s &nbsp;数据交换方法12345678910/** * a1 a2 相互交换 * @param a1 参数1 * @param a2 参数2 */public void exchange(Object a1,Object a2)&#123; Object temp=a1; a1=a2; a2=temp;&#125; &nbsp;选择排序：1234567891011121314151617181920/** * 选择排序 比较次数为N(N-1)/2 复杂程度为N²级别 * @param obj 传递一个需要排序的数组 */public void selectSort(Object obj)&#123; int [] objArray=(int[])obj; int size=objArray.length; for (int i = 0; i &lt;size; i++) &#123; int k=i; for (int j = k+1; j &lt; size; j++) &#123; if(objArray[j] &lt; objArray[k])&#123; k = j; //记下目前找到的最小值所在的位置 &#125; &#125; //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换 if(i != k)&#123; //交换a[i]和a[k] exchange(objArray[i],objArray[k]); &#125; &#125;&#125; &nbsp;插入排序1234567891011121314151617181920212223/** * 插入排序 最坏情况下 复杂程度为N²级别 * @param obj 传递一个需要排序的数组 */public void insertSort(Object obj)&#123; int [] objArray=(int[])obj; int size=objArray.length; for (int i = 1; i &lt; size; i++) &#123; //判断当前项是否比下一项小 if (objArray[i - 1] &gt; objArray[i]) &#123; int temp = objArray[i]; int j = i;//记录当前位置 while (j &gt; 0 &amp;&amp; objArray[j - 1] &gt; temp) &#123; objArray[j] = objArray[j - 1]; j--; &#125; objArray[j] = temp; &#125; &#125;&#125; &nbsp;希尔排序123456789101112131415161718192021222324252627/** * 希尔排序 只知道比上述2种排序快。。。 * * @param obj 需要排序对象 */public void shellSort(Object obj) &#123; int[] objArray = (int[]) obj; int h = objArray.length; // gap为步长，每次减为原来的一半。 for (int gap = h / 2; gap &gt; 0; gap /= 2) &#123; // 共gap个组，对每一组都执行直接插入排序 for (int i = 0; i &lt; gap; i++) &#123; for (int j = i + gap; j &lt; h; j += gap) &#123; // 如果a[j] &lt; a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。 if (objArray[j] &lt; objArray[j - gap]) &#123; int tmp = objArray[j]; int k = j - gap; while (k &gt;= 0 &amp;&amp; objArray[k] &gt; tmp) &#123; objArray[k + gap] = objArray[k]; k -= gap; &#125; objArray[k + gap] = tmp; &#125; &#125; &#125; &#125;&#125; &nbsp;归并排序12345678910111213141516171819202122232425262728/** * 归并排序 把大数组分为多组小数组排序后在整合排序 * @param obj 需要排序对象 */public void mergeSort(Object obj) &#123; int[] objArray = (int[]) obj; int N = objArray.length; int[] aux = new int[N]; for (int sz = 1; sz &lt; N; sz += sz) &#123; for (int lo = 0; lo &lt; N - sz; lo += sz + sz) &#123; // 在每轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小 int mid = lo + sz - 1; int hi = Math.min(lo + sz + sz - 1, N - 1); for (int k = lo; k &lt;= mid; k++) &#123; aux[k] = objArray[k]; &#125; for (int k = mid + 1; k &lt;= hi; k++) &#123; aux[k] = objArray[hi - k + mid + 1]; &#125; int i = lo, j = hi; // 从两端往中间 for (int k = lo; k &lt;= hi; k++) if (aux[i] &lt;= aux[j]) objArray[k] = aux[i++]; else objArray[k] = aux[j--]; &#125; &#125;&#125; &nbsp;快速排序1234567891011121314151617181920212223242526272829303132333435363738/** * 快速排序 * @param a * @param low 开始位置 * @param high 结束位置 */public void quickSort(int[] a,int low,int high)&#123; int start = low; int end = high; int key = a[low]; while(end&gt;start)&#123; //从后往前比较 //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较 while(end&gt;start&amp;&amp;a[end]&gt;=key) end--; if(a[end]&lt;=key)&#123; int temp = a[end]; a[end] = a[start]; a[start] = temp; &#125; //从前往后比较 //如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置 while(end&gt;start&amp;&amp;a[start]&lt;=key) start++; if(a[start]&gt;=key)&#123; int temp = a[start]; a[start] = a[end]; a[end] = temp; &#125; //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小 //右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用 &#125; //递归 if(start&gt;low) quickSort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1 if(end&lt;high) quickSort(a,end+1,high);//右边序列。从关键值索引+1到最后一个 &#125;","categories":[],"tags":[]},{"title":"我的收藏","slug":"myCollection","date":"2017-08-15T02:57:26.962Z","updated":"2017-12-20T08:27:02.020Z","comments":true,"path":"2017/08/15/myCollection/","link":"","permalink":"http://hujiachen822.github.io/2017/08/15/myCollection/","excerpt":"","text":"自己学习用的： Android： Android自定义控件之自定义组合控件安卓自定义View教程目录贝塞尔曲线公式及教学 AngularJS： RUNOOB.COM AngularJS参考手册RUNOOB.COM AngularJS实例","categories":[],"tags":[]},{"title":"Android性能/内存优化","slug":"appIncrease","date":"2017-08-14T03:12:57.037Z","updated":"2017-08-14T09:31:52.567Z","comments":true,"path":"2017/08/14/appIncrease/","link":"","permalink":"http://hujiachen822.github.io/2017/08/14/appIncrease/","excerpt":"","text":"&emsp;上周有幸去参加了APM大会有幸听到了猎豹移动分享的性能优化，下面就我在大会上的听到的内容进行下总结。 一、精简布局&nbsp;布局层次&nbsp;控件元素&nbsp;过度绘制 (图) 二、少用图片&nbsp;Drawable/自绘&nbsp;文字替代单色图&nbsp;自绘控件 三、异步加载&nbsp;插件框架&nbsp;执行顺序&nbsp;主线程刷新&nbsp;其他 四、延迟加载&nbsp;ViewStub&nbsp;PsotDelayed&nbsp;onFirstFrameDrawn 总结&nbsp;界面元素/层级越少越好&nbsp;主界面尽量少用图片&nbsp;主线程业务走 专用车道&nbsp;非紧急业务 错峰出行 内存优化方法&nbsp;使用更加轻量的数据结构&nbsp;使用更小的图片&nbsp;复用系统自带资源&nbsp;注意Cursor对象是否及时关闭&nbsp;特别留意单例对象不合理的持有 图片计算方法 res 分辨率 DensityDPI 机型 xhdpi 720x1280 320 Galaxy Nexus xxhdpi 1080x1920 480 Nexus5 xxxhdpi 1440x2560 640 Nexus6 123scale=(float)screenDensity/bitmapDensity;scaledWidth=int(bitmapWidth * scale + 0.5f);scaleHeight=int(bitmappHeight * scale + 0.5f); 同一张图在不同分辨率下的机型中所占的内存 类型 机型1 机型2 名称 Galaxy Nexus Nexus 6 大小 945KB 3.7MB 参数 screenDensity(320)xhdpi(320),bitmap(640*378) screenDensity(640),xhdpi(320),bitmap(640*378) .9的图片事例(略) RGB565 和 ARGB8888 的事例(略) 总结使用.9，尽量保证其足够精简化大为小，化繁为简用小图或者不用图文字替换单色图片尽量使用RGB565Bitmap内存尽量复用 (在Android 4.4以后 只要长宽&lt;=目标内存宽高即可复用 ，4.4前则需要长宽==目标内存宽高)内存中保存压缩后的图片用完及时释放图片内存 临时进程效果图(略) 内存优化的其他关键路径找出图片内存大户并优化找出废弃逻辑代码并删除找出执行过程耗费大量内存，具备一次性性质的逻辑迁到临时进程无法解决泄漏(如WebView) 移至其他进程坚决防止Activity内存泄露 GC是非常耗时的操作，使用越少内存程序越流畅。总之：不做事情则不耗内存。","categories":[],"tags":[]},{"title":"折线堆叠图实现 StrackLineChart","slug":"strackChart","date":"2017-08-09T03:33:09.507Z","updated":"2018-01-15T06:20:52.447Z","comments":true,"path":"2017/08/09/strackChart/","link":"","permalink":"http://hujiachen822.github.io/2017/08/09/strackChart/","excerpt":"","text":"MPAndroidChart本身是不支持折现堆叠图的(只支持折线图和填充图)那么什么是堆叠图呢？举个例子：[(x,y)] 为一条线比如有两条线分别为 [(1,1),(2,2),(3,3)],[(1,1),(2,2),(3,3)]，那么在堆叠图上所展示的两条线则为[(1,1),(2,2),(3,3)],[(1,2),(2,4),(3,6)]由此可见 堆叠图的纵坐标就是当前线的纵坐标与另一条线的纵坐标之和 好了废话不多说了，先上代码注意事项后面补上1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*** * 处理数据X，整理出姓名 * * @param series 为传过来的json串 我的demo jsonArrary格式 * nameArray 是Arraylist 姓名集合 代表线的名称 ArrayList&lt;String&gt; nameArray * xArray X点的集合 ArrayList&lt;Long&gt; xArray * lineX 为单独一条线的X集合 HashMap&lt;String, ArrayList&lt;Long&gt;&gt; lineX */ private void judgeDataY(JSONArray series, int lineNum) &#123; nameArray = new ArrayList&lt;&gt;(); int seriesLength = series.size(); for (int i = seriesLength - 1; i &gt;= 0; i--) &#123;// 线的数量 i JSONObject obj = series.getJSONObject(i); String objName=obj.getString(&quot;name&quot;); if(nameArray.contains(objName))&#123; objName=objName+i+&quot;&quot;; &#125; nameArray.add(objName); HashMap&lt;Long, Float&gt; yAxis = new HashMap&lt;&gt;(); ArrayList&lt;Long&gt; xAxis = new ArrayList&lt;&gt;(); JSONArray data = obj.getJSONArray(&quot;data&quot;); int dataLength = data.size(); for (int j = 0; j &lt; dataLength; j++) &#123;//点的数量 j JSONObject objData = data.getJSONObject(j); long xObjValue = objData.getLong(&quot;x&quot;); Float yObjValue = objData.getFloat(&quot;y&quot;); long xValue = xObjValue; Float yValue = yObjValue; if (j == dataLength - 1) &#123; xAxis.add(xValue); addYValue(i, seriesLength, xValue, yValue, yAxis, objData); for (int y1 = 0; y1 &lt; xArray.size(); y1++) &#123;// 补充X点 if (!xAxis.contains(xArray.get(y1))) &#123; addYValue(i, seriesLength, xValue, yValue, yAxis, objData); if (i == seriesLength - 1) &#123; yAxis.put(xArray.get(y1), 0f); &#125; else &#123; for (int y = 0; y &lt; xArray.size(); y++) &#123;//判断Ｘ是否相等 for (int a = 0; a &lt;= seriesLength - 2; a++) &#123; if (seriesLength &gt;= seriesLength - a &amp;&amp; i &lt;= seriesLength - a - 2 &amp;&amp; y &lt; lineX.get(nameArray.get(seriesLength - a - 2 - i)).size() &amp;&amp; lineX.get(nameArray.get(seriesLength - a - 2 - i)).get(y).equals(xArray.get(y1))) &#123;//判断上一条线 yValue = lineY.get(nameArray.get(seriesLength - a - 2 - i)).get(xArray.get(y1)); break; &#125;// 3 2 1 0 &#125; &#125; yAxis.put(xArray.get(y1), yValue); &#125; &#125; &#125; &#125; else &#123; xAxis.add(xValue); addYValue(i, seriesLength, xValue, yValue, yAxis, objData); &#125; &#125; Collections.sort(xAxis); lineX.put(objName, xAxis); lineY.put(objName, yAxis); &#125; &#125; // 堆叠 private void addYValue(int i, int seriesLength, long xValue, Float yValue, HashMap&lt;Long, Float&gt; yAxis, JSONObject objData) &#123; if (i == seriesLength - 1) &#123; yAxis.put(xValue, yValue); &#125; else &#123; for (int y = 0; y &lt; xArray.size(); y++) &#123;//判断Ｘ是否相等 for (int a = 0; a &lt;= seriesLength - 2; a++) &#123; if (seriesLength &gt;= seriesLength - a &amp;&amp; i &lt;= seriesLength - a - 2 &amp;&amp; y &lt; lineX.get(nameArray.get(seriesLength - a - 2 - i)).size() &amp;&amp; lineX.get(nameArray.get(seriesLength - a - 2 - i)).get(y).equals(objData.getLong(&quot;x&quot;))) &#123;//判断上一条线 yValue = lineY.get(nameArray.get(seriesLength - a - 2 - i)).get(xValue) + Float.parseFloat(objData.getString(&quot;y&quot;)); break; &#125; &#125; &#125; yAxis.put(xValue, yValue); &#125; &#125; 需要注意的是，当第二条线去做纵坐标相加的时候 所对应的第一条线X坐标不存在 ，这时咱们就要给那个X坐标添加上 X坐标为相应的X坐标 纵坐标为0 (x,0) 好了，关于折线堆叠图就说这么多吧如果有不懂的地方可以用下面的联系方式联系我 联系方式: hujiachen822@163.com/583567165","categories":[],"tags":[]},{"title":"MPAndroidChart增加折线图图例点击效果","slug":"legendClick","date":"2017-08-09T03:19:56.436Z","updated":"2017-08-09T07:20:25.401Z","comments":true,"path":"2017/08/09/legendClick/","link":"","permalink":"http://hujiachen822.github.io/2017/08/09/legendClick/","excerpt":"","text":"本例子是根据 MPAndroidChart:v2.2.5 版本添加 按照惯例线上图(堆叠图如何实现后面会写) 未点击图例: 点击图例: 提示：所有颜色部分可以用任意的色值不用在乎我的色值 上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//ArrayList&lt;String&gt; nameArray 用来存线名称(图例名称)//HashMap&lt;String, ArrayList&lt;Float&gt;&gt; lineY 用来存线Y轴数据的 &lt;String(线名称)//colorResource 字体颜色自己随意改//ArrayList&lt;HashMap&lt;String, Boolean&gt;&gt; isCheck 用来记录线的点击状态 是否被点击 private void setPicEx(final LineData mLineData, final LineChart mLineChart, final float addValue) &#123; // 用来存储每条线的最大值 final ArrayList&lt;Float&gt; maxYList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nameArray.size(); i++) &#123; maxYList.add(mLineData.getDataSetByIndex(i).getYMax()); &#125; if (null == mContext || &quot;null&quot;.equals(mContext)) &#123; &#125; else &#123; LayoutInflater layoutInflater = LayoutInflater.from(mContext.getApplicationContext()); final int count = lineY.size(); mView.removeAllViews(); for (int i = 0; i &lt; count; i++) &#123; View view = layoutInflater.inflate(R.layout.item_chart_ex, null, false); final LinearLayout ly = (LinearLayout) view.findViewById(R.id.picEx); final TextView txt = (TextView) view.findViewById(R.id.picName); txt.setTextColor(mContext.getResources().getColor(colorResource)); if (i &gt; colorArray.size()) &#123; ly.setBackgroundColor(Color.parseColor(colorArray.get(i / colorArray.size()))); &#125; else &#123; ly.setBackgroundColor(Color.parseColor(colorArray.get(i))); &#125; txt.setText(nameArray.get(i)); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; int index = 0; String name = txt.getText() + &quot;&quot;; // 获取第几个图例 for (int i = 0; i &lt; nameArray.size(); i++) &#123; if (name.equals(nameArray.get(i))) &#123; index = i; break; &#125; &#125; // 判断点击的是哪个图例 if (nameArray.get(index).equals(name)) &#123; if (isCheck.get(index).get(name)) &#123; ly.setBackgroundColor(Color.GRAY);// 设置灰色背景 mLineData.removeDataSet(index);//移除点击的图例数据 lineDataSets.add(index, new LineDataSet(null, name));// 添加一个null的数据弥补位置 isCheck.get(index).put(name, false);// 记录被点击状态 &#125; else &#123; if (index &gt; colorArray.size()) &#123;//行业均值点击 ly.setBackgroundColor(Color.parseColor(colorArray.get(index / colorArray.size())));// 设置背景颜色 &#125; else &#123; ly.setBackgroundColor(Color.parseColor(colorArray.get(index)));// 设置背景颜色 &#125; lineDataSets.remove(index);// 移除填充位置的数据 lineDataSets.add(index, lineDataSetsEmpty.get(index));//把数据填充到原来位置 isCheck.get(index).put(name, true);//取消记录的点击状态 &#125; &#125; mLineChart.notifyDataSetChanged(); mLineChart.invalidate();//更新UI if (useYMax.size() != 0) &#123; setMinValueClick(mLineChart); &#125; &#125; &#125;); mView.addView(view); if ((benchmarkName).equals(nameArray.get(i)) &amp;&amp; isVag) &#123; break; &#125; &#125; &#125; &#125; 这里是 R.layout.item_chart_ex 的 XML 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;40dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/picEx&quot; android:layout_centerVertical=&quot;true&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;12dp&quot; android:layout_marginLeft=&quot;5dp&quot; android:orientation=&quot;horizontal&quot; android:background=&quot;#000000&quot;/&gt; &lt;TextView android:padding=&quot;5dp&quot; android:id=&quot;@+id/picName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;center_vertical&quot; android:gravity=&quot;center&quot; android:text=&quot;XXX&quot; android:textColor=&quot;@color/fontColor&quot; android:textSize=&quot;12dp&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_toEndOf=&quot;@+id/picEx&quot; /&gt;&lt;/RelativeLayout&gt; 联系方式：hujiachen822@163.com 583567162t treeId) { this.treeId = treeId; } //用来接收 是否Browser标识 public void setIsBrowser(boolean isBrowser) { this.isBrowser = isBrowser; } //判断哪个path更改颜色 public void setDataColor(int forPositon, Paint mPaint) { mPaint.setColor(0xffDDDDDD); if (isBrowser) { for (int i = 0; i &lt; mPositon.size(); i++) { MapBean bean = mPositon.get(i); if (MapUtils.getLocalPosition(bean.getName()) == forPositon) { // MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean) 根据值在图例的区间内来上色 mPaint.setColor(MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean)); break; } else { } } } else { for (int i = 0; i &lt; mPositon.size(); i++) { MapBean bean = mPositon.get(i); // (MapUtils.getLocalPosition(bean.getY()) 根据地名来获得对应SVG模块的位置 if (MapUtils.getLocalPosition(bean.getY()) == forPositon) { // MapUtils.getStateColor(bean.getState()) 根据标识来上色 mPaint.setColor(MapUtils.getStateColor(bean.getState())); break; } else { } } } } @Override public boolean onTouchEvent(MotionEvent event) { //------关键部分 判断点是否在 一个闭合的path内--------// if (event.getAction() == MotionEvent.ACTION_DOWN) { MapBean a = new MapBean(); RectF mComputeRect = new RectF(); for (int i = 0; i &lt; mPaths.size(); i++) { mPaths.get(i).path.computeBounds(mComputeRect, true); Region region = new Region(); region.setPath(mPaths.get(i).path, new Region((int) mComputeRect.left, (int) mComputeRect.top, (int) mComputeRect.right, (int) mComputeRect.bottom)); // #号来标识的地方是我自己用来存储点击位置显示内容 # if (region.contains((int) event.getX(), (int) event.getY())) { String name = MapUtils.getMapName(i); String value = &quot;暂无数据&quot;; for (int x = 0; x &lt; mPositon.size(); x++) { if (mPositon.get(x).getName().contains(name)) { value = mPositon.get(x).getY(); } } a.setX(value); a.setY(name);# invokeProvinceListener(a); break; } } } return true; } @Override protected void onSizeChanged(final int w, final int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (mLoader != null) { try { mLoader.join(); } catch (InterruptedException e) { Log.e(LOG_TAG, &quot;Unexpected error&quot;, e); } } mLoader = new Thread(new Runnable() { @Override public void run() { mSvg.load(getContext(), mSvgResource); synchronized (mSvgLock) { mPaths = mSvg.getPathsForViewport( w - getPaddingLeft() - getPaddingRight(), h - getPaddingTop() - getPaddingBottom()); updatePathsPhaseLocked(); } post(new Runnable() { @Override public void run() { invokeReadyListener(); if (mSvgAnimator.isRunning()) mSvgAnimator.cancel(); mSvgAnimator.start(); } }); } }, &quot;SVG Loader&quot;); mLoader.start(); } private void invokeReadyListener() { if (mListener != null) mListener.onReady(); } public void setOnReadyListener(OnReadyListener listener) { mListener = listener; } private void updatePathsPhaseLocked() { final int count = mPaths.size(); for (int i = 0; i &lt; count; i++) { SvgHelper.SvgPath svgPath = mPaths.get(i); svgPath.renderPath.reset(); svgPath.measure.getSegment(0.0f, svgPath.length * mPhase, svgPath.renderPath, true); // Required only for Android 4.4 and earlier svgPath.renderPath.rLineTo(0.0f, 0.0f); } } public float getPhase() { return mPhase; } public void setPhase(float phase) { mPhase = phase; synchronized (mSvgLock) { updatePathsPhaseLocked(); } invalidate(); } public float getWait() { return mWait; } public void setWait(float wait) { mWait = wait; invalidate(); } public float getDrag() { return mDrag; } public void setDrag(float drag) { mDrag = drag; int alpha = (int) (Math.min((1.0f - mDrag) * mFadeFactor, 1.0f) * 255.0f); mDragPath.paint.setAlpha(alpha); invalidate(); } private static PathEffect createPathEffect(float pathLength, float phase, float offset) { return new DashPathEffect(new float[]{pathLength, pathLength}, Math.max(phase * pathLength, offset)); } private static Path makeDragPath(int radius) { Path p = new Path(); RectF oval = new RectF(0.0f, 0.0f, radius * 2.0f, radius * 2.0f); float cx = oval.centerX(); float cy = oval.centerY(); float rx = oval.width() / 2.0f; float ry = oval.height() / 2.0f; final float TAN_PI_OVER_8 = 0.414213562f; final float ROOT_2_OVER_2 = 0.707106781f; float sx = rx * TAN_PI_OVER_8; float sy = ry * TAN_PI_OVER_8; float mx = rx * ROOT_2_OVER_2; float my = ry * ROOT_2_OVER_2; float L = oval.left; float T = oval.top; float R = oval.right; float B = oval.bottom; p.moveTo(R, cy); p.quadTo(R, cy + sy, cx + mx, cy + my); p.quadTo(cx + sx, B, cx, B); p.quadTo(cx - sx, B, cx - mx, cy + my); p.quadTo(L, cy + sy, L, cy); p.quadTo(L, cy - sy, cx - mx, cy - my); p.quadTo(cx - sx, T, cx, T); p.lineTo(cx, T - oval.height() * 1.3f); return p; } } 1234&lt;b&gt; 工具类代码如下&lt;/b&gt;##### &lt;b&gt; 根据状态判断颜色&lt;/br&gt; public static int getStateColor(String state) { int color = 0; switch (state) { case “0”: color = 0xff5bc750; break; case “1”: color = 0xffa7d25b; break; case “2”: color = 0xfff7de4d; break; case “3”: color = 0xfffd9141; break; case “4”: color = 0xfff4534e; break; } return color; } 1##### &lt;b&gt; 根据省份名称，来判断是第几个path改变颜色&lt;/br&gt; public static int getLocalPosition(String name) { int i = -1; if (name.contains(“安徽”)) { i = 0; } else if (name.contains(“北京”)) { i = 1; } else if (name.contains(“重庆”)) { i = 2; } else if (name.contains(“福建”)) { i = 3; } else if (name.contains(“广东”)) { i = 4; } else if (name.contains(“甘肃”)) { i = 5; } else if (name.contains(“广西”)) { i = 6; } else if (name.contains(“贵州”)) { i = 7; } else if (name.contains(“海南”)) { i = 8; } else if (name.contains(“河北”)) { i = 9; } else if (name.contains(“河南”)) { i = 10; } else if (name.contains(“香港”)) { i = 11; } else if (name.contains(“黑龙江”)) { i = 12; } else if (name.contains(“湖南”)) { i = 13; } else if (name.contains(“湖北”)) { i = 14; } else if (name.contains(“吉林”)) { i = 15; } else if (name.contains(“江苏”)) { i = 16; } else if (name.contains(“江西”)) { i = 17; } else if (name.contains(“辽宁”)) { i = 18; } else if (name.contains(“澳门”)) { i = 19; } else if (name.contains(“内蒙古”)) { i = 20; } else if (name.contains(“宁夏”)) { i = 21; } else if (name.contains(“青海”)) { i = 22; } else if (name.contains(“陕西”)) { i = 23; } else if (name.contains(“四川”)) { i = 24; } else if (name.contains(“山东”)) { i = 25; } else if (name.contains(“上海”)) { i = 26; } else if (name.contains(“山西”)) { i = 27; } else if (name.contains(“天津”)) { i = 28; } else if (name.contains(“台湾”)) { i = 29; } else if (name.contains(“新疆”)) { i = 30; } else if (name.contains(“西藏”)) { i = 31; } else if (name.contains(“云南”)) { i = 32; } else if (name.contains(“浙江”)) { i = 33; } return i; } 1##### &lt;b&gt; 根据SVG点击位置，获取省份名称&lt;/br&gt; public static String getMapName(int position) { String name = “省份”; if (0 == position) { name = “安徽”; } else if (1 == position) { name = “北京”; } else if (2 == position) { name = “重庆”; } else if (3 == position) { name = “福建”; } else if (4 == position) { name = “广东”; } else if (5 == position) { name = “甘肃”; } else if (6 == position) { name = “广西”; } else if (7 == position) { name = “贵州”; } else if (8 == position) { name = “海南”; } else if (9 == position) { name = “河北”; } else if (10 == position) { name = “河南”; } else if (11 == position) { name = “香港”; } else if (12 == position) { name = “黑龙江”; } else if (13 == position) { name = “湖南”; } else if (14 == position) { name = “湖北”; } else if (15 == position) { name = “吉林”; } else if (16 == position) { name = “江苏”; } else if (17 == position) { name = “江西”; } else if (18 == position) { name = “辽宁”; } else if (19 == position) { name = “澳门”; } else if (20 == position) { name = “内蒙古”; } else if (21 == position) { name = “宁夏”; } else if (22 == position) { name = “青海”; } else if (23 == position) { name = “陕西”; } else if (24 == position) { name = “四川”; } else if (25 == position) { name = “山东”; } else if (26 == position) { name = “上海”; } else if (27 == position) { name = “山西”; } else if (28 == position) { name = “天津”; } else if (29 == position) { name = “台湾”; } else if (30 == position) { name = “新疆”; } else if (31 == position) { name = “西藏”; } else if (32 == position) { name = “云南”; } else if (33 == position) { name = “浙江”; } return name; } ``` 好了，关于折线图例点击就说这么多吧如果有不懂的地方可以用下面的联系方式联系我 联系方式: hujiachen822@163.com/583567165","categories":[],"tags":[]},{"title":"SVG格式地图显示并获取点击位置","slug":"mapChart","date":"2017-08-08T07:56:43.313Z","updated":"2017-08-09T07:20:13.369Z","comments":true,"path":"2017/08/08/mapChart/","link":"","permalink":"http://hujiachen822.github.io/2017/08/08/mapChart/","excerpt":"","text":"是根据github上作品 IntroView 改进而来的。(作者对不起我忘记了你的地址了) SVG下载链接 废话不多说了，先上图 : 图1 点击的为地图左上角红色的色块 图2 点击的为地图上无色块的地方 下面上自定义控件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357@SuppressWarnings(&#123;&quot;ForLoopReplaceableByForEach&quot;, &quot;UnusedDeclaration&quot;&#125;)public class IntroViewBrowser extends View &#123; private static final String LOG_TAG = &quot;IntroView&quot;; private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); private final Paint mPaint2 = new Paint(Paint.ANTI_ALIAS_FLAG); private final SvgHelper mSvg = new SvgHelper(mPaint); private int mSvgResource; private final Object mSvgLock = new Object(); private List&lt;SvgHelper.SvgPath&gt; mPaths = new ArrayList&lt;SvgHelper.SvgPath&gt;(0); private Thread mLoader; private SvgHelper.SvgPath mWaitPath; private SvgHelper.SvgPath mDragPath; private float mPhase; private float mWait; private float mDrag; private int mDuration; private float mFadeFactor; private int mRadius; private ObjectAnimator mSvgAnimator; private ObjectAnimator mWaitAnimator; private OnReadyListener mListener; public interface OnReadyListener &#123; void onReady(); &#125; private OnProvinceListener mProvince; public interface OnProvinceListener &#123; void onProvince(MapBean bean); &#125; private void invokeProvinceListener(MapBean bean) &#123; if (mProvince != null) mProvince.onProvince(bean); &#125; public void setOnProvinceListener(OnProvinceListener listener) &#123; mProvince = listener; &#125; public IntroViewBrowser(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public IntroViewBrowser(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IntroView, defStyle, 0); try &#123; if (a != null) &#123; mPaint2.setStrokeWidth(a.getFloat(R.styleable.IntroView_strokeWidth, 10.0f)); mPaint.setColor(a.getColor(R.styleable.IntroView_strokeColor, 0xff000000)); mPhase = a.getFloat(R.styleable.IntroView_phase, 1.0f); mDuration = a.getInt(R.styleable.IntroView_duration, 4000); mFadeFactor = a.getFloat(R.styleable.IntroView_fadeFactor, 10.0f); mRadius = a.getDimensionPixelSize(R.styleable.IntroView_waitRadius, 50); &#125; &#125; finally &#123; if (a != null) a.recycle(); &#125; init(); &#125; private void init() &#123; mPaint.setStyle(Paint.Style.FILL); mPaint2.setStyle(Paint.Style.STROKE); mPaint2.setColor(0xff999999); createWaitPath(); setLayerType(LAYER_TYPE_SOFTWARE, null); mSvgAnimator = ObjectAnimator.ofFloat(this, &quot;phase&quot;, 0.0f, 1.0f).setDuration(mDuration); mWaitAnimator = ObjectAnimator.ofFloat(this, &quot;wait&quot;, 1.0f, 0.0f).setDuration(mDuration); mWaitAnimator.setRepeatMode(ObjectAnimator.RESTART); mWaitAnimator.setRepeatCount(ObjectAnimator.INFINITE); mWaitAnimator.setInterpolator(new LinearInterpolator()); mWaitAnimator.start(); &#125; private void createWaitPath() &#123; Paint paint = new Paint(mPaint); paint.setStrokeWidth(paint.getStrokeWidth() * 4.0f); Path p = new Path(); p.moveTo(0.0f, 0.0f); p.lineTo(mRadius * 6.0f, 0.0f); mWaitPath = new SvgHelper.SvgPath(p, paint); paint = new Paint(mWaitPath.paint); mDragPath = new SvgHelper.SvgPath(makeDragPath(mRadius), paint); &#125; public void setSvgResource(int resource) &#123; if (mSvgResource == 0) &#123; mSvgResource = resource; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); synchronized (mSvgLock) &#123; canvas.save(); final int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; SvgHelper.SvgPath svgPath = mPaths.get(i); int alpha = (int) (Math.min(mPhase * mFadeFactor, 1.0f) * 255.0f); svgPath.paint.setAlpha(alpha); setDataColor(i, svgPath.paint); canvas.drawPath(svgPath.path, mPaint2); canvas.drawPath(svgPath.path, svgPath.paint); &#125; canvas.restore(); &#125; canvas.save(); canvas.translate(0.0f, getHeight() - getPaddingBottom() - mRadius * 3.0f); if (mWaitPath.paint.getAlpha() &gt; 0) &#123; canvas.translate(getWidth() / 2.0f - mRadius * 3.0f, mRadius); canvas.drawPath(mWaitPath.path, mWaitPath.paint); &#125; else &#123; canvas.translate((getWidth() - mDragPath.bounds.width()) / 2.0f, 0.0f); canvas.drawPath(mDragPath.path, mDragPath.paint); &#125; canvas.restore(); &#125; // 实体类 private List&lt;MapBean&gt; mPositon = new ArrayList&lt;&gt;(); private List&lt;LabelBean&gt; mLabelBean; private int treeId = 1; private boolean isBrowser = false; Region re = new Region(); //用来接收数据 public void setSvgPosition(List&lt;MapBean&gt; positon) &#123; mPositon = positon; &#125; //用来接收Label Label为上面的图例 public void setSvgLableBean(List&lt;LabelBean&gt; mLabelBean) &#123; this.mLabelBean = mLabelBean; &#125; //用来接收Browser TreeId public void setBrowserTreeId(int treeId) &#123; this.treeId = treeId; &#125; //用来接收 是否Browser标识 public void setIsBrowser(boolean isBrowser) &#123; this.isBrowser = isBrowser; &#125; //判断哪个path更改颜色 public void setDataColor(int forPositon, Paint mPaint) &#123; mPaint.setColor(0xffDDDDDD); if (isBrowser) &#123; for (int i = 0; i &lt; mPositon.size(); i++) &#123; MapBean bean = mPositon.get(i); if (MapUtils.getLocalPosition(bean.getName()) == forPositon) &#123; // MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean) 根据值在图例的区间内来上色 mPaint.setColor(MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean)); break; &#125; else &#123; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; mPositon.size(); i++) &#123; MapBean bean = mPositon.get(i); // (MapUtils.getLocalPosition(bean.getY()) 根据地名来获得对应SVG模块的位置 if (MapUtils.getLocalPosition(bean.getY()) == forPositon) &#123; // MapUtils.getStateColor(bean.getState()) 根据标识来上色 mPaint.setColor(MapUtils.getStateColor(bean.getState())); break; &#125; else &#123; &#125; &#125; &#125; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; //------关键部分 判断点是否在 一个闭合的path内--------// if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; MapBean a = new MapBean(); RectF mComputeRect = new RectF(); for (int i = 0; i &lt; mPaths.size(); i++) &#123; mPaths.get(i).path.computeBounds(mComputeRect, true); Region region = new Region(); region.setPath(mPaths.get(i).path, new Region((int) mComputeRect.left, (int) mComputeRect.top, (int) mComputeRect.right, (int) mComputeRect.bottom)); // #号来标识的地方是我自己用来存储点击位置显示内容 # if (region.contains((int) event.getX(), (int) event.getY())) &#123; String name = MapUtils.getMapName(i); String value = &quot;暂无数据&quot;; for (int x = 0; x &lt; mPositon.size(); x++) &#123; if (mPositon.get(x).getName().contains(name)) &#123; value = mPositon.get(x).getY(); &#125; &#125; a.setX(value); a.setY(name);# invokeProvinceListener(a); break; &#125; &#125; &#125; return true; &#125; @Override protected void onSizeChanged(final int w, final int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mLoader != null) &#123; try &#123; mLoader.join(); &#125; catch (InterruptedException e) &#123; Log.e(LOG_TAG, &quot;Unexpected error&quot;, e); &#125; &#125; mLoader = new Thread(new Runnable() &#123; @Override public void run() &#123; mSvg.load(getContext(), mSvgResource); synchronized (mSvgLock) &#123; mPaths = mSvg.getPathsForViewport( w - getPaddingLeft() - getPaddingRight(), h - getPaddingTop() - getPaddingBottom()); updatePathsPhaseLocked(); &#125; post(new Runnable() &#123; @Override public void run() &#123; invokeReadyListener(); if (mSvgAnimator.isRunning()) mSvgAnimator.cancel(); mSvgAnimator.start(); &#125; &#125;); &#125; &#125;, &quot;SVG Loader&quot;); mLoader.start(); &#125; private void invokeReadyListener() &#123; if (mListener != null) mListener.onReady(); &#125; public void setOnReadyListener(OnReadyListener listener) &#123; mListener = listener; &#125; private void updatePathsPhaseLocked() &#123; final int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; SvgHelper.SvgPath svgPath = mPaths.get(i); svgPath.renderPath.reset(); svgPath.measure.getSegment(0.0f, svgPath.length * mPhase, svgPath.renderPath, true); // Required only for Android 4.4 and earlier svgPath.renderPath.rLineTo(0.0f, 0.0f); &#125; &#125; public float getPhase() &#123; return mPhase; &#125; public void setPhase(float phase) &#123; mPhase = phase; synchronized (mSvgLock) &#123; updatePathsPhaseLocked(); &#125; invalidate(); &#125; public float getWait() &#123; return mWait; &#125; public void setWait(float wait) &#123; mWait = wait; invalidate(); &#125; public float getDrag() &#123; return mDrag; &#125; public void setDrag(float drag) &#123; mDrag = drag; int alpha = (int) (Math.min((1.0f - mDrag) * mFadeFactor, 1.0f) * 255.0f); mDragPath.paint.setAlpha(alpha); invalidate(); &#125; private static PathEffect createPathEffect(float pathLength, float phase, float offset) &#123; return new DashPathEffect(new float[]&#123;pathLength, pathLength&#125;, Math.max(phase * pathLength, offset)); &#125; private static Path makeDragPath(int radius) &#123; Path p = new Path(); RectF oval = new RectF(0.0f, 0.0f, radius * 2.0f, radius * 2.0f); float cx = oval.centerX(); float cy = oval.centerY(); float rx = oval.width() / 2.0f; float ry = oval.height() / 2.0f; final float TAN_PI_OVER_8 = 0.414213562f; final float ROOT_2_OVER_2 = 0.707106781f; float sx = rx * TAN_PI_OVER_8; float sy = ry * TAN_PI_OVER_8; float mx = rx * ROOT_2_OVER_2; float my = ry * ROOT_2_OVER_2; float L = oval.left; float T = oval.top; float R = oval.right; float B = oval.bottom; p.moveTo(R, cy); p.quadTo(R, cy + sy, cx + mx, cy + my); p.quadTo(cx + sx, B, cx, B); p.quadTo(cx - sx, B, cx - mx, cy + my); p.quadTo(L, cy + sy, L, cy); p.quadTo(L, cy - sy, cx - mx, cy - my); p.quadTo(cx - sx, T, cx, T); p.lineTo(cx, T - oval.height() * 1.3f); return p; &#125;&#125; 工具类代码如下 根据状态判断颜色123456789101112131415161718192021public static int getStateColor(String state) &#123; int color = 0; switch (state) &#123; case &quot;0&quot;: color = 0xff5bc750; break; case &quot;1&quot;: color = 0xffa7d25b; break; case &quot;2&quot;: color = 0xfff7de4d; break; case &quot;3&quot;: color = 0xfffd9141; break; case &quot;4&quot;: color = 0xfff4534e; break; &#125; return color; &#125; 根据省份名称，来判断是第几个path改变颜色12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static int getLocalPosition(String name) &#123; int i = -1; if (name.contains(&quot;安徽&quot;)) &#123; i = 0; &#125; else if (name.contains(&quot;北京&quot;)) &#123; i = 1; &#125; else if (name.contains(&quot;重庆&quot;)) &#123; i = 2; &#125; else if (name.contains(&quot;福建&quot;)) &#123; i = 3; &#125; else if (name.contains(&quot;广东&quot;)) &#123; i = 4; &#125; else if (name.contains(&quot;甘肃&quot;)) &#123; i = 5; &#125; else if (name.contains(&quot;广西&quot;)) &#123; i = 6; &#125; else if (name.contains(&quot;贵州&quot;)) &#123; i = 7; &#125; else if (name.contains(&quot;海南&quot;)) &#123; i = 8; &#125; else if (name.contains(&quot;河北&quot;)) &#123; i = 9; &#125; else if (name.contains(&quot;河南&quot;)) &#123; i = 10; &#125; else if (name.contains(&quot;香港&quot;)) &#123; i = 11; &#125; else if (name.contains(&quot;黑龙江&quot;)) &#123; i = 12; &#125; else if (name.contains(&quot;湖南&quot;)) &#123; i = 13; &#125; else if (name.contains(&quot;湖北&quot;)) &#123; i = 14; &#125; else if (name.contains(&quot;吉林&quot;)) &#123; i = 15; &#125; else if (name.contains(&quot;江苏&quot;)) &#123; i = 16; &#125; else if (name.contains(&quot;江西&quot;)) &#123; i = 17; &#125; else if (name.contains(&quot;辽宁&quot;)) &#123; i = 18; &#125; else if (name.contains(&quot;澳门&quot;)) &#123; i = 19; &#125; else if (name.contains(&quot;内蒙古&quot;)) &#123; i = 20; &#125; else if (name.contains(&quot;宁夏&quot;)) &#123; i = 21; &#125; else if (name.contains(&quot;青海&quot;)) &#123; i = 22; &#125; else if (name.contains(&quot;陕西&quot;)) &#123; i = 23; &#125; else if (name.contains(&quot;四川&quot;)) &#123; i = 24; &#125; else if (name.contains(&quot;山东&quot;)) &#123; i = 25; &#125; else if (name.contains(&quot;上海&quot;)) &#123; i = 26; &#125; else if (name.contains(&quot;山西&quot;)) &#123; i = 27; &#125; else if (name.contains(&quot;天津&quot;)) &#123; i = 28; &#125; else if (name.contains(&quot;台湾&quot;)) &#123; i = 29; &#125; else if (name.contains(&quot;新疆&quot;)) &#123; i = 30; &#125; else if (name.contains(&quot;西藏&quot;)) &#123; i = 31; &#125; else if (name.contains(&quot;云南&quot;)) &#123; i = 32; &#125; else if (name.contains(&quot;浙江&quot;)) &#123; i = 33; &#125; return i; &#125; 根据SVG点击位置，获取省份名称12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static String getMapName(int position) &#123; String name = &quot;省份&quot;; if (0 == position) &#123; name = &quot;安徽&quot;; &#125; else if (1 == position) &#123; name = &quot;北京&quot;; &#125; else if (2 == position) &#123; name = &quot;重庆&quot;; &#125; else if (3 == position) &#123; name = &quot;福建&quot;; &#125; else if (4 == position) &#123; name = &quot;广东&quot;; &#125; else if (5 == position) &#123; name = &quot;甘肃&quot;; &#125; else if (6 == position) &#123; name = &quot;广西&quot;; &#125; else if (7 == position) &#123; name = &quot;贵州&quot;; &#125; else if (8 == position) &#123; name = &quot;海南&quot;; &#125; else if (9 == position) &#123; name = &quot;河北&quot;; &#125; else if (10 == position) &#123; name = &quot;河南&quot;; &#125; else if (11 == position) &#123; name = &quot;香港&quot;; &#125; else if (12 == position) &#123; name = &quot;黑龙江&quot;; &#125; else if (13 == position) &#123; name = &quot;湖南&quot;; &#125; else if (14 == position) &#123; name = &quot;湖北&quot;; &#125; else if (15 == position) &#123; name = &quot;吉林&quot;; &#125; else if (16 == position) &#123; name = &quot;江苏&quot;; &#125; else if (17 == position) &#123; name = &quot;江西&quot;; &#125; else if (18 == position) &#123; name = &quot;辽宁&quot;; &#125; else if (19 == position) &#123; name = &quot;澳门&quot;; &#125; else if (20 == position) &#123; name = &quot;内蒙古&quot;; &#125; else if (21 == position) &#123; name = &quot;宁夏&quot;; &#125; else if (22 == position) &#123; name = &quot;青海&quot;; &#125; else if (23 == position) &#123; name = &quot;陕西&quot;; &#125; else if (24 == position) &#123; name = &quot;四川&quot;; &#125; else if (25 == position) &#123; name = &quot;山东&quot;; &#125; else if (26 == position) &#123; name = &quot;上海&quot;; &#125; else if (27 == position) &#123; name = &quot;山西&quot;; &#125; else if (28 == position) &#123; name = &quot;天津&quot;; &#125; else if (29 == position) &#123; name = &quot;台湾&quot;; &#125; else if (30 == position) &#123; name = &quot;新疆&quot;; &#125; else if (31 == position) &#123; name = &quot;西藏&quot;; &#125; else if (32 == position) &#123; name = &quot;云南&quot;; &#125; else if (33 == position) &#123; name = &quot;浙江&quot;; &#125; return name; &#125; 好了，关于SVG地图就说这么多吧如果有不懂的地方可以用下面的联系方式联系我 联系方式：hujiachen822@163.com/583567162","categories":[],"tags":[]}]}