{"meta":{"title":"Hujiachen's Blog","subtitle":null,"description":null,"author":"胡佳晨","url":"http://hujiachen822.github.io"},"pages":[],"posts":[{"title":"Android性能/内存优化","slug":"性能优化","date":"2017-08-14T03:12:57.037Z","updated":"2017-08-14T09:22:01.446Z","comments":true,"path":"2017/08/14/性能优化/","link":"","permalink":"http://hujiachen822.github.io/2017/08/14/性能优化/","excerpt":"","text":"&emsp;上周有幸去参加了APM大会有幸听到了猎豹移动分享的性能优化，下面就我在大会上的听到的内容进行下总结。 一、精简布局&nbsp;布局层次&nbsp;控件元素&nbsp;过度绘制 (图) 二、少用图片&nbsp;Drawable/自绘&nbsp;文字替代单色图&nbsp;自绘控件 三、异步加载&nbsp;插件框架&nbsp;执行顺序&nbsp;主线程刷新&nbsp;其他 四、延迟加载&nbsp;ViewStub&nbsp;PsotDelayed&nbsp;onFirstFrameDrawn 总结&nbsp;界面元素/层级越少越好&nbsp;主界面尽量少用图片&nbsp;主线程业务走 专用车道&nbsp;非紧急业务 错峰出行 内存优化方法&nbsp;使用更加轻量的数据结构&nbsp;使用更小的图片&nbsp;复用系统自带资源&nbsp;注意Cursor对象是否及时关闭&nbsp;特别留意单例对象不合理的持有 图片计算方法 res 分辨率 DensityDPI 机型 xhdpi 720x1280 320 Galaxy Nexus xxhdpi 1080x1920 480 Nexus5 xxxhdpi 1440x2560 640 Nexus6 123scale=(float)screenDensity/bitmapDensity;scaledWidth=int(bitmapWidth * scale + 0.5f);scaleHeight=int(bitmappHeight * scale + 0.5f); 类型 机型1 机型2 名称|Galaxy Nexus|Nexus 6大小|945KB|3.7MB参数|screenDensity(320)xhdpi(320),bitmap(640378)|screenDensity(640),xhdpi(320),bitmap(640378) .9的图片事例(略) RGB565 和 ARGB8888 的事例(略) 总结使用.9，尽量保证其足够精简化大为小，化繁为简用小图或者不用图文字替换单色图片尽量使用RGB565Bitmap内存尽量复用 (在Android 4.4以后 只要长宽&lt;=目标内存宽高即可复用 ，4.4前则需要长宽==目标内存宽高)内存中保存压缩后的图片用完及时释放图片内存 临时进程效果图(略) 内存优化的其他关键路径找出图片内存大户并优化找出废弃逻辑代码并删除找出执行过程耗费大量内存，具备一次性性质的逻辑迁到临时进程无法解决泄漏(如WebView) 移至其他进程坚决防止Activity内存泄露 GC是非常耗时的操作，使用越少内存程序越流畅。不做事情则不耗内存。","categories":[],"tags":[]},{"title":"折线堆叠图实现 StrackLineChart","slug":"strackChart","date":"2017-08-09T03:33:09.507Z","updated":"2017-08-09T07:20:16.945Z","comments":true,"path":"2017/08/09/strackChart/","link":"","permalink":"http://hujiachen822.github.io/2017/08/09/strackChart/","excerpt":"","text":"MPAndroidChart本身是不支持折现堆叠图的(只支持折线图和填充图)那么什么是堆叠图呢？举个例子：[(x,y)] 为一条线比如有两条线分别为 [(1,1),(2,2),(3,3)],[(1,1),(2,2),(3,3)]，那么在堆叠图上所展示的两条线则为[(1,1),(2,2),(3,3)],[(1,2),(2,4),(3,6)]由此可见 堆叠图的纵坐标就是当前线的纵坐标与另一条线的纵坐标之和 好了废话不多说了，先上代码注意事项后面补上1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*** * 处理数据X，整理出姓名 * * @param series 为传过来的json串 我的demo jsonArrary格式 * nameArray 是Arraylist 姓名集合 代表线的名称 ArrayList&lt;String&gt; nameArray * xArray X点的集合 ArrayList&lt;Long&gt; xArray * lineX 为单独一条线的X集合 HashMap&lt;String, ArrayList&lt;Long&gt;&gt; lineX */ private void judgeDataY(JSONArray series, int lineNum) &#123; nameArray = new ArrayList&lt;&gt;(); int seriesLength = series.size(); for (int i = seriesLength - 1; i &gt;= 0; i--) &#123;// 线的数量 i JSONObject obj = series.getJSONObject(i); String objName=obj.getString(&quot;name&quot;); if(nameArray.contains(objName))&#123; objName=objName+i+&quot;&quot;; &#125; nameArray.add(objName); HashMap&lt;Long, Float&gt; yAxis = new HashMap&lt;&gt;(); ArrayList&lt;Long&gt; xAxis = new ArrayList&lt;&gt;(); JSONArray data = obj.getJSONArray(&quot;data&quot;); int dataLength = data.size(); for (int j = 0; j &lt; dataLength; j++) &#123;//点的数量 j JSONObject objData = data.getJSONObject(j); long xObjValue = objData.getLong(&quot;x&quot;); Float yObjValue = objData.getFloat(&quot;y&quot;); long xValue = xObjValue; Float yValue = yObjValue; if (j == dataLength - 1) &#123; xAxis.add(xValue); addYValue(i, seriesLength, xValue, yValue, yAxis, objData); for (int y1 = 0; y1 &lt; xArray.size(); y1++) &#123;// 补充X点 if (!xAxis.contains(xArray.get(y1))) &#123; addYValue(i, seriesLength, xValue, yValue, yAxis, objData); if (i == seriesLength - 1) &#123; yAxis.put(xArray.get(y1), 0f); &#125; else &#123; for (int y = 0; y &lt; xArray.size(); y++) &#123;//判断Ｘ是否相等 for (int a = 0; a &lt;= seriesLength - 2; a++) &#123; if (seriesLength &gt;= seriesLength - a &amp;&amp; i &lt;= seriesLength - a - 2 &amp;&amp; y &lt; lineX.get(nameArray.get(seriesLength - a - 2 - i)).size() &amp;&amp; lineX.get(nameArray.get(seriesLength - a - 2 - i)).get(y).equals(xArray.get(y1))) &#123;//判断上一条线 yValue = lineY.get(nameArray.get(seriesLength - a - 2 - i)).get(xArray.get(y1)); break; &#125;// 3 2 1 0 &#125; &#125; yAxis.put(xArray.get(y1), yValue); &#125; &#125; &#125; &#125; else &#123; xAxis.add(xValue); addYValue(i, seriesLength, xValue, yValue, yAxis, objData); &#125; &#125; Collections.sort(xAxis); lineX.put(objName, xAxis); lineY.put(objName, yAxis); &#125; &#125; // 堆叠 private void addYValue(int i, int seriesLength, long xValue, Float yValue, HashMap&lt;Long, Float&gt; yAxis, JSONObject objData) &#123; if (i == seriesLength - 1) &#123; yAxis.put(xValue, yValue); &#125; else &#123; for (int y = 0; y &lt; xArray.size(); y++) &#123;//判断Ｘ是否相等 for (int a = 0; a &lt;= seriesLength - 2; a++) &#123; if (seriesLength &gt;= seriesLength - a &amp;&amp; i &lt;= seriesLength - a - 2 &amp;&amp; y &lt; lineX.get(nameArray.get(seriesLength - a - 2 - i)).size() &amp;&amp; lineX.get(nameArray.get(seriesLength - a - 2 - i)).get(y).equals(objData.getLong(&quot;x&quot;))) &#123;//判断上一条线 yValue = lineY.get(nameArray.get(seriesLength - a - 2 - i)).get(xValue) + Float.parseFloat(objData.getString(&quot;y&quot;)); break; &#125; &#125; &#125; yAxis.put(xValue, yValue); &#125; &#125; 需要注意的是，当第二条线去做纵坐标相加的时候 所对应的第一条线X坐标不存在 ，这时咱们就要给那个X坐标添加上 X坐标为相应的X坐标 纵坐标为0 (x,0) 好了，关于折线堆叠图就说这么多吧如果有不懂的地方可以用下面的联系方式联系我 联系方式: hujiachen822@163.com/583567165","categories":[],"tags":[]},{"title":"MPAndroidChart增加折线图图例点击效果","slug":"legendClick","date":"2017-08-09T03:19:56.436Z","updated":"2017-08-09T07:20:25.401Z","comments":true,"path":"2017/08/09/legendClick/","link":"","permalink":"http://hujiachen822.github.io/2017/08/09/legendClick/","excerpt":"","text":"本例子是根据 MPAndroidChart:v2.2.5 版本添加 按照惯例线上图(堆叠图如何实现后面会写) 未点击图例: 点击图例: 提示：所有颜色部分可以用任意的色值不用在乎我的色值 上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//ArrayList&lt;String&gt; nameArray 用来存线名称(图例名称)//HashMap&lt;String, ArrayList&lt;Float&gt;&gt; lineY 用来存线Y轴数据的 &lt;String(线名称)//colorResource 字体颜色自己随意改//ArrayList&lt;HashMap&lt;String, Boolean&gt;&gt; isCheck 用来记录线的点击状态 是否被点击 private void setPicEx(final LineData mLineData, final LineChart mLineChart, final float addValue) &#123; // 用来存储每条线的最大值 final ArrayList&lt;Float&gt; maxYList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nameArray.size(); i++) &#123; maxYList.add(mLineData.getDataSetByIndex(i).getYMax()); &#125; if (null == mContext || &quot;null&quot;.equals(mContext)) &#123; &#125; else &#123; LayoutInflater layoutInflater = LayoutInflater.from(mContext.getApplicationContext()); final int count = lineY.size(); mView.removeAllViews(); for (int i = 0; i &lt; count; i++) &#123; View view = layoutInflater.inflate(R.layout.item_chart_ex, null, false); final LinearLayout ly = (LinearLayout) view.findViewById(R.id.picEx); final TextView txt = (TextView) view.findViewById(R.id.picName); txt.setTextColor(mContext.getResources().getColor(colorResource)); if (i &gt; colorArray.size()) &#123; ly.setBackgroundColor(Color.parseColor(colorArray.get(i / colorArray.size()))); &#125; else &#123; ly.setBackgroundColor(Color.parseColor(colorArray.get(i))); &#125; txt.setText(nameArray.get(i)); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; int index = 0; String name = txt.getText() + &quot;&quot;; // 获取第几个图例 for (int i = 0; i &lt; nameArray.size(); i++) &#123; if (name.equals(nameArray.get(i))) &#123; index = i; break; &#125; &#125; // 判断点击的是哪个图例 if (nameArray.get(index).equals(name)) &#123; if (isCheck.get(index).get(name)) &#123; ly.setBackgroundColor(Color.GRAY);// 设置灰色背景 mLineData.removeDataSet(index);//移除点击的图例数据 lineDataSets.add(index, new LineDataSet(null, name));// 添加一个null的数据弥补位置 isCheck.get(index).put(name, false);// 记录被点击状态 &#125; else &#123; if (index &gt; colorArray.size()) &#123;//行业均值点击 ly.setBackgroundColor(Color.parseColor(colorArray.get(index / colorArray.size())));// 设置背景颜色 &#125; else &#123; ly.setBackgroundColor(Color.parseColor(colorArray.get(index)));// 设置背景颜色 &#125; lineDataSets.remove(index);// 移除填充位置的数据 lineDataSets.add(index, lineDataSetsEmpty.get(index));//把数据填充到原来位置 isCheck.get(index).put(name, true);//取消记录的点击状态 &#125; &#125; mLineChart.notifyDataSetChanged(); mLineChart.invalidate();//更新UI if (useYMax.size() != 0) &#123; setMinValueClick(mLineChart); &#125; &#125; &#125;); mView.addView(view); if ((benchmarkName).equals(nameArray.get(i)) &amp;&amp; isVag) &#123; break; &#125; &#125; &#125; &#125; 这里是 R.layout.item_chart_ex 的 XML 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;40dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/picEx&quot; android:layout_centerVertical=&quot;true&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;12dp&quot; android:layout_marginLeft=&quot;5dp&quot; android:orientation=&quot;horizontal&quot; android:background=&quot;#000000&quot;/&gt; &lt;TextView android:padding=&quot;5dp&quot; android:id=&quot;@+id/picName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;center_vertical&quot; android:gravity=&quot;center&quot; android:text=&quot;XXX&quot; android:textColor=&quot;@color/fontColor&quot; android:textSize=&quot;12dp&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_toEndOf=&quot;@+id/picEx&quot; /&gt;&lt;/RelativeLayout&gt; 联系方式：hujiachen822@163.com 583567162t treeId) { this.treeId = treeId; } //用来接收 是否Browser标识 public void setIsBrowser(boolean isBrowser) { this.isBrowser = isBrowser; } //判断哪个path更改颜色 public void setDataColor(int forPositon, Paint mPaint) { mPaint.setColor(0xffDDDDDD); if (isBrowser) { for (int i = 0; i &lt; mPositon.size(); i++) { MapBean bean = mPositon.get(i); if (MapUtils.getLocalPosition(bean.getName()) == forPositon) { // MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean) 根据值在图例的区间内来上色 mPaint.setColor(MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean)); break; } else { } } } else { for (int i = 0; i &lt; mPositon.size(); i++) { MapBean bean = mPositon.get(i); // (MapUtils.getLocalPosition(bean.getY()) 根据地名来获得对应SVG模块的位置 if (MapUtils.getLocalPosition(bean.getY()) == forPositon) { // MapUtils.getStateColor(bean.getState()) 根据标识来上色 mPaint.setColor(MapUtils.getStateColor(bean.getState())); break; } else { } } } } @Override public boolean onTouchEvent(MotionEvent event) { //------关键部分 判断点是否在 一个闭合的path内--------// if (event.getAction() == MotionEvent.ACTION_DOWN) { MapBean a = new MapBean(); RectF mComputeRect = new RectF(); for (int i = 0; i &lt; mPaths.size(); i++) { mPaths.get(i).path.computeBounds(mComputeRect, true); Region region = new Region(); region.setPath(mPaths.get(i).path, new Region((int) mComputeRect.left, (int) mComputeRect.top, (int) mComputeRect.right, (int) mComputeRect.bottom)); // #号来标识的地方是我自己用来存储点击位置显示内容 # if (region.contains((int) event.getX(), (int) event.getY())) { String name = MapUtils.getMapName(i); String value = &quot;暂无数据&quot;; for (int x = 0; x &lt; mPositon.size(); x++) { if (mPositon.get(x).getName().contains(name)) { value = mPositon.get(x).getY(); } } a.setX(value); a.setY(name);# invokeProvinceListener(a); break; } } } return true; } @Override protected void onSizeChanged(final int w, final int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (mLoader != null) { try { mLoader.join(); } catch (InterruptedException e) { Log.e(LOG_TAG, &quot;Unexpected error&quot;, e); } } mLoader = new Thread(new Runnable() { @Override public void run() { mSvg.load(getContext(), mSvgResource); synchronized (mSvgLock) { mPaths = mSvg.getPathsForViewport( w - getPaddingLeft() - getPaddingRight(), h - getPaddingTop() - getPaddingBottom()); updatePathsPhaseLocked(); } post(new Runnable() { @Override public void run() { invokeReadyListener(); if (mSvgAnimator.isRunning()) mSvgAnimator.cancel(); mSvgAnimator.start(); } }); } }, &quot;SVG Loader&quot;); mLoader.start(); } private void invokeReadyListener() { if (mListener != null) mListener.onReady(); } public void setOnReadyListener(OnReadyListener listener) { mListener = listener; } private void updatePathsPhaseLocked() { final int count = mPaths.size(); for (int i = 0; i &lt; count; i++) { SvgHelper.SvgPath svgPath = mPaths.get(i); svgPath.renderPath.reset(); svgPath.measure.getSegment(0.0f, svgPath.length * mPhase, svgPath.renderPath, true); // Required only for Android 4.4 and earlier svgPath.renderPath.rLineTo(0.0f, 0.0f); } } public float getPhase() { return mPhase; } public void setPhase(float phase) { mPhase = phase; synchronized (mSvgLock) { updatePathsPhaseLocked(); } invalidate(); } public float getWait() { return mWait; } public void setWait(float wait) { mWait = wait; invalidate(); } public float getDrag() { return mDrag; } public void setDrag(float drag) { mDrag = drag; int alpha = (int) (Math.min((1.0f - mDrag) * mFadeFactor, 1.0f) * 255.0f); mDragPath.paint.setAlpha(alpha); invalidate(); } private static PathEffect createPathEffect(float pathLength, float phase, float offset) { return new DashPathEffect(new float[]{pathLength, pathLength}, Math.max(phase * pathLength, offset)); } private static Path makeDragPath(int radius) { Path p = new Path(); RectF oval = new RectF(0.0f, 0.0f, radius * 2.0f, radius * 2.0f); float cx = oval.centerX(); float cy = oval.centerY(); float rx = oval.width() / 2.0f; float ry = oval.height() / 2.0f; final float TAN_PI_OVER_8 = 0.414213562f; final float ROOT_2_OVER_2 = 0.707106781f; float sx = rx * TAN_PI_OVER_8; float sy = ry * TAN_PI_OVER_8; float mx = rx * ROOT_2_OVER_2; float my = ry * ROOT_2_OVER_2; float L = oval.left; float T = oval.top; float R = oval.right; float B = oval.bottom; p.moveTo(R, cy); p.quadTo(R, cy + sy, cx + mx, cy + my); p.quadTo(cx + sx, B, cx, B); p.quadTo(cx - sx, B, cx - mx, cy + my); p.quadTo(L, cy + sy, L, cy); p.quadTo(L, cy - sy, cx - mx, cy - my); p.quadTo(cx - sx, T, cx, T); p.lineTo(cx, T - oval.height() * 1.3f); return p; } } 1234&lt;b&gt; 工具类代码如下&lt;/b&gt;##### &lt;b&gt; 根据状态判断颜色&lt;/br&gt; public static int getStateColor(String state) { int color = 0; switch (state) { case “0”: color = 0xff5bc750; break; case “1”: color = 0xffa7d25b; break; case “2”: color = 0xfff7de4d; break; case “3”: color = 0xfffd9141; break; case “4”: color = 0xfff4534e; break; } return color; } 1##### &lt;b&gt; 根据省份名称，来判断是第几个path改变颜色&lt;/br&gt; public static int getLocalPosition(String name) { int i = -1; if (name.contains(“安徽”)) { i = 0; } else if (name.contains(“北京”)) { i = 1; } else if (name.contains(“重庆”)) { i = 2; } else if (name.contains(“福建”)) { i = 3; } else if (name.contains(“广东”)) { i = 4; } else if (name.contains(“甘肃”)) { i = 5; } else if (name.contains(“广西”)) { i = 6; } else if (name.contains(“贵州”)) { i = 7; } else if (name.contains(“海南”)) { i = 8; } else if (name.contains(“河北”)) { i = 9; } else if (name.contains(“河南”)) { i = 10; } else if (name.contains(“香港”)) { i = 11; } else if (name.contains(“黑龙江”)) { i = 12; } else if (name.contains(“湖南”)) { i = 13; } else if (name.contains(“湖北”)) { i = 14; } else if (name.contains(“吉林”)) { i = 15; } else if (name.contains(“江苏”)) { i = 16; } else if (name.contains(“江西”)) { i = 17; } else if (name.contains(“辽宁”)) { i = 18; } else if (name.contains(“澳门”)) { i = 19; } else if (name.contains(“内蒙古”)) { i = 20; } else if (name.contains(“宁夏”)) { i = 21; } else if (name.contains(“青海”)) { i = 22; } else if (name.contains(“陕西”)) { i = 23; } else if (name.contains(“四川”)) { i = 24; } else if (name.contains(“山东”)) { i = 25; } else if (name.contains(“上海”)) { i = 26; } else if (name.contains(“山西”)) { i = 27; } else if (name.contains(“天津”)) { i = 28; } else if (name.contains(“台湾”)) { i = 29; } else if (name.contains(“新疆”)) { i = 30; } else if (name.contains(“西藏”)) { i = 31; } else if (name.contains(“云南”)) { i = 32; } else if (name.contains(“浙江”)) { i = 33; } return i; } 1##### &lt;b&gt; 根据SVG点击位置，获取省份名称&lt;/br&gt; public static String getMapName(int position) { String name = “省份”; if (0 == position) { name = “安徽”; } else if (1 == position) { name = “北京”; } else if (2 == position) { name = “重庆”; } else if (3 == position) { name = “福建”; } else if (4 == position) { name = “广东”; } else if (5 == position) { name = “甘肃”; } else if (6 == position) { name = “广西”; } else if (7 == position) { name = “贵州”; } else if (8 == position) { name = “海南”; } else if (9 == position) { name = “河北”; } else if (10 == position) { name = “河南”; } else if (11 == position) { name = “香港”; } else if (12 == position) { name = “黑龙江”; } else if (13 == position) { name = “湖南”; } else if (14 == position) { name = “湖北”; } else if (15 == position) { name = “吉林”; } else if (16 == position) { name = “江苏”; } else if (17 == position) { name = “江西”; } else if (18 == position) { name = “辽宁”; } else if (19 == position) { name = “澳门”; } else if (20 == position) { name = “内蒙古”; } else if (21 == position) { name = “宁夏”; } else if (22 == position) { name = “青海”; } else if (23 == position) { name = “陕西”; } else if (24 == position) { name = “四川”; } else if (25 == position) { name = “山东”; } else if (26 == position) { name = “上海”; } else if (27 == position) { name = “山西”; } else if (28 == position) { name = “天津”; } else if (29 == position) { name = “台湾”; } else if (30 == position) { name = “新疆”; } else if (31 == position) { name = “西藏”; } else if (32 == position) { name = “云南”; } else if (33 == position) { name = “浙江”; } return name; } ``` 好了，关于折线图例点击就说这么多吧如果有不懂的地方可以用下面的联系方式联系我 联系方式: hujiachen822@163.com/583567165","categories":[],"tags":[]},{"title":"SVG格式地图显示并获取点击位置","slug":"mapChart","date":"2017-08-08T07:56:43.313Z","updated":"2017-08-09T07:20:13.369Z","comments":true,"path":"2017/08/08/mapChart/","link":"","permalink":"http://hujiachen822.github.io/2017/08/08/mapChart/","excerpt":"","text":"是根据github上作品 IntroView 改进而来的。(作者对不起我忘记了你的地址了) SVG下载链接 废话不多说了，先上图 : 图1 点击的为地图左上角红色的色块 图2 点击的为地图上无色块的地方 下面上自定义控件代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357@SuppressWarnings(&#123;&quot;ForLoopReplaceableByForEach&quot;, &quot;UnusedDeclaration&quot;&#125;)public class IntroViewBrowser extends View &#123; private static final String LOG_TAG = &quot;IntroView&quot;; private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); private final Paint mPaint2 = new Paint(Paint.ANTI_ALIAS_FLAG); private final SvgHelper mSvg = new SvgHelper(mPaint); private int mSvgResource; private final Object mSvgLock = new Object(); private List&lt;SvgHelper.SvgPath&gt; mPaths = new ArrayList&lt;SvgHelper.SvgPath&gt;(0); private Thread mLoader; private SvgHelper.SvgPath mWaitPath; private SvgHelper.SvgPath mDragPath; private float mPhase; private float mWait; private float mDrag; private int mDuration; private float mFadeFactor; private int mRadius; private ObjectAnimator mSvgAnimator; private ObjectAnimator mWaitAnimator; private OnReadyListener mListener; public interface OnReadyListener &#123; void onReady(); &#125; private OnProvinceListener mProvince; public interface OnProvinceListener &#123; void onProvince(MapBean bean); &#125; private void invokeProvinceListener(MapBean bean) &#123; if (mProvince != null) mProvince.onProvince(bean); &#125; public void setOnProvinceListener(OnProvinceListener listener) &#123; mProvince = listener; &#125; public IntroViewBrowser(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public IntroViewBrowser(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IntroView, defStyle, 0); try &#123; if (a != null) &#123; mPaint2.setStrokeWidth(a.getFloat(R.styleable.IntroView_strokeWidth, 10.0f)); mPaint.setColor(a.getColor(R.styleable.IntroView_strokeColor, 0xff000000)); mPhase = a.getFloat(R.styleable.IntroView_phase, 1.0f); mDuration = a.getInt(R.styleable.IntroView_duration, 4000); mFadeFactor = a.getFloat(R.styleable.IntroView_fadeFactor, 10.0f); mRadius = a.getDimensionPixelSize(R.styleable.IntroView_waitRadius, 50); &#125; &#125; finally &#123; if (a != null) a.recycle(); &#125; init(); &#125; private void init() &#123; mPaint.setStyle(Paint.Style.FILL); mPaint2.setStyle(Paint.Style.STROKE); mPaint2.setColor(0xff999999); createWaitPath(); setLayerType(LAYER_TYPE_SOFTWARE, null); mSvgAnimator = ObjectAnimator.ofFloat(this, &quot;phase&quot;, 0.0f, 1.0f).setDuration(mDuration); mWaitAnimator = ObjectAnimator.ofFloat(this, &quot;wait&quot;, 1.0f, 0.0f).setDuration(mDuration); mWaitAnimator.setRepeatMode(ObjectAnimator.RESTART); mWaitAnimator.setRepeatCount(ObjectAnimator.INFINITE); mWaitAnimator.setInterpolator(new LinearInterpolator()); mWaitAnimator.start(); &#125; private void createWaitPath() &#123; Paint paint = new Paint(mPaint); paint.setStrokeWidth(paint.getStrokeWidth() * 4.0f); Path p = new Path(); p.moveTo(0.0f, 0.0f); p.lineTo(mRadius * 6.0f, 0.0f); mWaitPath = new SvgHelper.SvgPath(p, paint); paint = new Paint(mWaitPath.paint); mDragPath = new SvgHelper.SvgPath(makeDragPath(mRadius), paint); &#125; public void setSvgResource(int resource) &#123; if (mSvgResource == 0) &#123; mSvgResource = resource; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); synchronized (mSvgLock) &#123; canvas.save(); final int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; SvgHelper.SvgPath svgPath = mPaths.get(i); int alpha = (int) (Math.min(mPhase * mFadeFactor, 1.0f) * 255.0f); svgPath.paint.setAlpha(alpha); setDataColor(i, svgPath.paint); canvas.drawPath(svgPath.path, mPaint2); canvas.drawPath(svgPath.path, svgPath.paint); &#125; canvas.restore(); &#125; canvas.save(); canvas.translate(0.0f, getHeight() - getPaddingBottom() - mRadius * 3.0f); if (mWaitPath.paint.getAlpha() &gt; 0) &#123; canvas.translate(getWidth() / 2.0f - mRadius * 3.0f, mRadius); canvas.drawPath(mWaitPath.path, mWaitPath.paint); &#125; else &#123; canvas.translate((getWidth() - mDragPath.bounds.width()) / 2.0f, 0.0f); canvas.drawPath(mDragPath.path, mDragPath.paint); &#125; canvas.restore(); &#125; // 实体类 private List&lt;MapBean&gt; mPositon = new ArrayList&lt;&gt;(); private List&lt;LabelBean&gt; mLabelBean; private int treeId = 1; private boolean isBrowser = false; Region re = new Region(); //用来接收数据 public void setSvgPosition(List&lt;MapBean&gt; positon) &#123; mPositon = positon; &#125; //用来接收Label Label为上面的图例 public void setSvgLableBean(List&lt;LabelBean&gt; mLabelBean) &#123; this.mLabelBean = mLabelBean; &#125; //用来接收Browser TreeId public void setBrowserTreeId(int treeId) &#123; this.treeId = treeId; &#125; //用来接收 是否Browser标识 public void setIsBrowser(boolean isBrowser) &#123; this.isBrowser = isBrowser; &#125; //判断哪个path更改颜色 public void setDataColor(int forPositon, Paint mPaint) &#123; mPaint.setColor(0xffDDDDDD); if (isBrowser) &#123; for (int i = 0; i &lt; mPositon.size(); i++) &#123; MapBean bean = mPositon.get(i); if (MapUtils.getLocalPosition(bean.getName()) == forPositon) &#123; // MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean) 根据值在图例的区间内来上色 mPaint.setColor(MapUtils.getValueColor(Double.parseDouble(bean.getY()), mLabelBean)); break; &#125; else &#123; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; mPositon.size(); i++) &#123; MapBean bean = mPositon.get(i); // (MapUtils.getLocalPosition(bean.getY()) 根据地名来获得对应SVG模块的位置 if (MapUtils.getLocalPosition(bean.getY()) == forPositon) &#123; // MapUtils.getStateColor(bean.getState()) 根据标识来上色 mPaint.setColor(MapUtils.getStateColor(bean.getState())); break; &#125; else &#123; &#125; &#125; &#125; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; //------关键部分 判断点是否在 一个闭合的path内--------// if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; MapBean a = new MapBean(); RectF mComputeRect = new RectF(); for (int i = 0; i &lt; mPaths.size(); i++) &#123; mPaths.get(i).path.computeBounds(mComputeRect, true); Region region = new Region(); region.setPath(mPaths.get(i).path, new Region((int) mComputeRect.left, (int) mComputeRect.top, (int) mComputeRect.right, (int) mComputeRect.bottom)); // #号来标识的地方是我自己用来存储点击位置显示内容 # if (region.contains((int) event.getX(), (int) event.getY())) &#123; String name = MapUtils.getMapName(i); String value = &quot;暂无数据&quot;; for (int x = 0; x &lt; mPositon.size(); x++) &#123; if (mPositon.get(x).getName().contains(name)) &#123; value = mPositon.get(x).getY(); &#125; &#125; a.setX(value); a.setY(name);# invokeProvinceListener(a); break; &#125; &#125; &#125; return true; &#125; @Override protected void onSizeChanged(final int w, final int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (mLoader != null) &#123; try &#123; mLoader.join(); &#125; catch (InterruptedException e) &#123; Log.e(LOG_TAG, &quot;Unexpected error&quot;, e); &#125; &#125; mLoader = new Thread(new Runnable() &#123; @Override public void run() &#123; mSvg.load(getContext(), mSvgResource); synchronized (mSvgLock) &#123; mPaths = mSvg.getPathsForViewport( w - getPaddingLeft() - getPaddingRight(), h - getPaddingTop() - getPaddingBottom()); updatePathsPhaseLocked(); &#125; post(new Runnable() &#123; @Override public void run() &#123; invokeReadyListener(); if (mSvgAnimator.isRunning()) mSvgAnimator.cancel(); mSvgAnimator.start(); &#125; &#125;); &#125; &#125;, &quot;SVG Loader&quot;); mLoader.start(); &#125; private void invokeReadyListener() &#123; if (mListener != null) mListener.onReady(); &#125; public void setOnReadyListener(OnReadyListener listener) &#123; mListener = listener; &#125; private void updatePathsPhaseLocked() &#123; final int count = mPaths.size(); for (int i = 0; i &lt; count; i++) &#123; SvgHelper.SvgPath svgPath = mPaths.get(i); svgPath.renderPath.reset(); svgPath.measure.getSegment(0.0f, svgPath.length * mPhase, svgPath.renderPath, true); // Required only for Android 4.4 and earlier svgPath.renderPath.rLineTo(0.0f, 0.0f); &#125; &#125; public float getPhase() &#123; return mPhase; &#125; public void setPhase(float phase) &#123; mPhase = phase; synchronized (mSvgLock) &#123; updatePathsPhaseLocked(); &#125; invalidate(); &#125; public float getWait() &#123; return mWait; &#125; public void setWait(float wait) &#123; mWait = wait; invalidate(); &#125; public float getDrag() &#123; return mDrag; &#125; public void setDrag(float drag) &#123; mDrag = drag; int alpha = (int) (Math.min((1.0f - mDrag) * mFadeFactor, 1.0f) * 255.0f); mDragPath.paint.setAlpha(alpha); invalidate(); &#125; private static PathEffect createPathEffect(float pathLength, float phase, float offset) &#123; return new DashPathEffect(new float[]&#123;pathLength, pathLength&#125;, Math.max(phase * pathLength, offset)); &#125; private static Path makeDragPath(int radius) &#123; Path p = new Path(); RectF oval = new RectF(0.0f, 0.0f, radius * 2.0f, radius * 2.0f); float cx = oval.centerX(); float cy = oval.centerY(); float rx = oval.width() / 2.0f; float ry = oval.height() / 2.0f; final float TAN_PI_OVER_8 = 0.414213562f; final float ROOT_2_OVER_2 = 0.707106781f; float sx = rx * TAN_PI_OVER_8; float sy = ry * TAN_PI_OVER_8; float mx = rx * ROOT_2_OVER_2; float my = ry * ROOT_2_OVER_2; float L = oval.left; float T = oval.top; float R = oval.right; float B = oval.bottom; p.moveTo(R, cy); p.quadTo(R, cy + sy, cx + mx, cy + my); p.quadTo(cx + sx, B, cx, B); p.quadTo(cx - sx, B, cx - mx, cy + my); p.quadTo(L, cy + sy, L, cy); p.quadTo(L, cy - sy, cx - mx, cy - my); p.quadTo(cx - sx, T, cx, T); p.lineTo(cx, T - oval.height() * 1.3f); return p; &#125;&#125; 工具类代码如下 根据状态判断颜色123456789101112131415161718192021public static int getStateColor(String state) &#123; int color = 0; switch (state) &#123; case &quot;0&quot;: color = 0xff5bc750; break; case &quot;1&quot;: color = 0xffa7d25b; break; case &quot;2&quot;: color = 0xfff7de4d; break; case &quot;3&quot;: color = 0xfffd9141; break; case &quot;4&quot;: color = 0xfff4534e; break; &#125; return color; &#125; 根据省份名称，来判断是第几个path改变颜色12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static int getLocalPosition(String name) &#123; int i = -1; if (name.contains(&quot;安徽&quot;)) &#123; i = 0; &#125; else if (name.contains(&quot;北京&quot;)) &#123; i = 1; &#125; else if (name.contains(&quot;重庆&quot;)) &#123; i = 2; &#125; else if (name.contains(&quot;福建&quot;)) &#123; i = 3; &#125; else if (name.contains(&quot;广东&quot;)) &#123; i = 4; &#125; else if (name.contains(&quot;甘肃&quot;)) &#123; i = 5; &#125; else if (name.contains(&quot;广西&quot;)) &#123; i = 6; &#125; else if (name.contains(&quot;贵州&quot;)) &#123; i = 7; &#125; else if (name.contains(&quot;海南&quot;)) &#123; i = 8; &#125; else if (name.contains(&quot;河北&quot;)) &#123; i = 9; &#125; else if (name.contains(&quot;河南&quot;)) &#123; i = 10; &#125; else if (name.contains(&quot;香港&quot;)) &#123; i = 11; &#125; else if (name.contains(&quot;黑龙江&quot;)) &#123; i = 12; &#125; else if (name.contains(&quot;湖南&quot;)) &#123; i = 13; &#125; else if (name.contains(&quot;湖北&quot;)) &#123; i = 14; &#125; else if (name.contains(&quot;吉林&quot;)) &#123; i = 15; &#125; else if (name.contains(&quot;江苏&quot;)) &#123; i = 16; &#125; else if (name.contains(&quot;江西&quot;)) &#123; i = 17; &#125; else if (name.contains(&quot;辽宁&quot;)) &#123; i = 18; &#125; else if (name.contains(&quot;澳门&quot;)) &#123; i = 19; &#125; else if (name.contains(&quot;内蒙古&quot;)) &#123; i = 20; &#125; else if (name.contains(&quot;宁夏&quot;)) &#123; i = 21; &#125; else if (name.contains(&quot;青海&quot;)) &#123; i = 22; &#125; else if (name.contains(&quot;陕西&quot;)) &#123; i = 23; &#125; else if (name.contains(&quot;四川&quot;)) &#123; i = 24; &#125; else if (name.contains(&quot;山东&quot;)) &#123; i = 25; &#125; else if (name.contains(&quot;上海&quot;)) &#123; i = 26; &#125; else if (name.contains(&quot;山西&quot;)) &#123; i = 27; &#125; else if (name.contains(&quot;天津&quot;)) &#123; i = 28; &#125; else if (name.contains(&quot;台湾&quot;)) &#123; i = 29; &#125; else if (name.contains(&quot;新疆&quot;)) &#123; i = 30; &#125; else if (name.contains(&quot;西藏&quot;)) &#123; i = 31; &#125; else if (name.contains(&quot;云南&quot;)) &#123; i = 32; &#125; else if (name.contains(&quot;浙江&quot;)) &#123; i = 33; &#125; return i; &#125; 根据SVG点击位置，获取省份名称12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static String getMapName(int position) &#123; String name = &quot;省份&quot;; if (0 == position) &#123; name = &quot;安徽&quot;; &#125; else if (1 == position) &#123; name = &quot;北京&quot;; &#125; else if (2 == position) &#123; name = &quot;重庆&quot;; &#125; else if (3 == position) &#123; name = &quot;福建&quot;; &#125; else if (4 == position) &#123; name = &quot;广东&quot;; &#125; else if (5 == position) &#123; name = &quot;甘肃&quot;; &#125; else if (6 == position) &#123; name = &quot;广西&quot;; &#125; else if (7 == position) &#123; name = &quot;贵州&quot;; &#125; else if (8 == position) &#123; name = &quot;海南&quot;; &#125; else if (9 == position) &#123; name = &quot;河北&quot;; &#125; else if (10 == position) &#123; name = &quot;河南&quot;; &#125; else if (11 == position) &#123; name = &quot;香港&quot;; &#125; else if (12 == position) &#123; name = &quot;黑龙江&quot;; &#125; else if (13 == position) &#123; name = &quot;湖南&quot;; &#125; else if (14 == position) &#123; name = &quot;湖北&quot;; &#125; else if (15 == position) &#123; name = &quot;吉林&quot;; &#125; else if (16 == position) &#123; name = &quot;江苏&quot;; &#125; else if (17 == position) &#123; name = &quot;江西&quot;; &#125; else if (18 == position) &#123; name = &quot;辽宁&quot;; &#125; else if (19 == position) &#123; name = &quot;澳门&quot;; &#125; else if (20 == position) &#123; name = &quot;内蒙古&quot;; &#125; else if (21 == position) &#123; name = &quot;宁夏&quot;; &#125; else if (22 == position) &#123; name = &quot;青海&quot;; &#125; else if (23 == position) &#123; name = &quot;陕西&quot;; &#125; else if (24 == position) &#123; name = &quot;四川&quot;; &#125; else if (25 == position) &#123; name = &quot;山东&quot;; &#125; else if (26 == position) &#123; name = &quot;上海&quot;; &#125; else if (27 == position) &#123; name = &quot;山西&quot;; &#125; else if (28 == position) &#123; name = &quot;天津&quot;; &#125; else if (29 == position) &#123; name = &quot;台湾&quot;; &#125; else if (30 == position) &#123; name = &quot;新疆&quot;; &#125; else if (31 == position) &#123; name = &quot;西藏&quot;; &#125; else if (32 == position) &#123; name = &quot;云南&quot;; &#125; else if (33 == position) &#123; name = &quot;浙江&quot;; &#125; return name; &#125; 好了，关于SVG地图就说这么多吧如果有不懂的地方可以用下面的联系方式联系我 联系方式：hujiachen822@163.com/583567162","categories":[],"tags":[]}]}