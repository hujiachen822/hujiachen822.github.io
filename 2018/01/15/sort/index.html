<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>算法：排序学习笔记 | Hujiachen's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">算法：排序学习笔记</h1><a id="logo" href="/.">Hujiachen's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">算法：排序学习笔记</h1><div class="post-meta">Jan 15, 2018</div><div class="post-content"><p>&nbsp;数据交换方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * a1 a2 相互交换</div><div class="line"> * @param a1 参数1</div><div class="line"> * @param a2 参数2</div><div class="line"> */</div><div class="line">public void exchange(Object a1,Object a2)&#123;</div><div class="line">	Object temp=a1;</div><div class="line">	a1=a2;</div><div class="line">	a2=temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;选择排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 选择排序 比较次数为N(N-1)/2  复杂程度为N²级别</div><div class="line"> * @param obj 传递一个需要排序的数组</div><div class="line"> */</div><div class="line">public void selectSort(Object obj)&#123;</div><div class="line">	int [] objArray=(int[])obj;</div><div class="line">	int size=objArray.length;</div><div class="line">	for (int i = 0; i &lt;size; i++) &#123;</div><div class="line">		int k=i;</div><div class="line">		for (int j = k+1; j &lt; size; j++) &#123;</div><div class="line">			if(objArray[j] &lt; objArray[k])&#123; </div><div class="line">                   k = j; //记下目前找到的最小值所在的位置</div><div class="line">               &#125;</div><div class="line">		&#125;</div><div class="line">		 //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</div><div class="line">           if(i != k)&#123;  //交换a[i]和a[k]</div><div class="line">           	exchange(objArray[i],objArray[k]);</div><div class="line">           &#125;    </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;插入排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 插入排序 最坏情况下 复杂程度为N²级别</div><div class="line"> * @param obj 传递一个需要排序的数组</div><div class="line"> */</div><div class="line">public void insertSort(Object obj)&#123;</div><div class="line">	int [] objArray=(int[])obj;</div><div class="line">	int size=objArray.length;</div><div class="line">	for (int i = 1; i &lt; size; i++)</div><div class="line">       &#123;</div><div class="line">		//判断当前项是否比下一项小</div><div class="line">           if (objArray[i - 1] &gt; objArray[i])</div><div class="line">           &#123;</div><div class="line">               int temp = objArray[i];</div><div class="line">               int j = i;//记录当前位置</div><div class="line">               while (j &gt; 0 &amp;&amp; objArray[j - 1] &gt; temp)</div><div class="line">               &#123;</div><div class="line">               	objArray[j] = objArray[j - 1];</div><div class="line">                   j--;</div><div class="line">               &#125;</div><div class="line">               objArray[j] = temp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;希尔排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 希尔排序 只知道比上述2种排序快。。。</div><div class="line"> * </div><div class="line"> * @param obj 需要排序对象</div><div class="line"> */</div><div class="line">public void shellSort(Object obj) &#123;</div><div class="line">	int[] objArray = (int[]) obj;</div><div class="line">	int h = objArray.length;</div><div class="line">	// gap为步长，每次减为原来的一半。</div><div class="line">	for (int gap = h / 2; gap &gt; 0; gap /= 2) &#123;</div><div class="line">		// 共gap个组，对每一组都执行直接插入排序</div><div class="line">		for (int i = 0; i &lt; gap; i++) &#123;</div><div class="line">			for (int j = i + gap; j &lt; h; j += gap) &#123;</div><div class="line">				// 如果a[j] &lt; a[j-gap]，则寻找a[j]位置，并将后面数据的位置都后移。</div><div class="line">				if (objArray[j] &lt; objArray[j - gap]) &#123;</div><div class="line">					int tmp = objArray[j];</div><div class="line">					int k = j - gap;</div><div class="line">					while (k &gt;= 0 &amp;&amp; objArray[k] &gt; tmp) &#123;</div><div class="line">						objArray[k + gap] = objArray[k];</div><div class="line">						k -= gap;</div><div class="line">					&#125;</div><div class="line">					objArray[k + gap] = tmp;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;归并排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 归并排序 把大数组分为多组小数组排序后在整合排序 </div><div class="line"> * @param obj 需要排序对象</div><div class="line"> */</div><div class="line">public void mergeSort(Object obj) &#123;</div><div class="line">	int[] objArray = (int[]) obj;</div><div class="line">	int N = objArray.length;</div><div class="line">	int[] aux = new int[N];</div><div class="line">	for (int sz = 1; sz &lt; N; sz += sz) &#123;</div><div class="line">		for (int lo = 0; lo &lt; N - sz; lo += sz + sz) &#123;</div><div class="line">			// 在每轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小</div><div class="line">			int mid = lo + sz - 1;</div><div class="line">			int hi = Math.min(lo + sz + sz - 1, N - 1);</div><div class="line">			for (int k = lo; k &lt;= mid; k++) &#123;</div><div class="line">				aux[k] = objArray[k];</div><div class="line">			&#125;</div><div class="line">			for (int k = mid + 1; k &lt;= hi; k++) &#123;</div><div class="line">				aux[k] = objArray[hi - k + mid + 1];</div><div class="line">			&#125;</div><div class="line">			int i = lo, j = hi; // 从两端往中间</div><div class="line">			for (int k = lo; k &lt;= hi; k++)</div><div class="line">				if (aux[i] &lt;= aux[j])</div><div class="line">					objArray[k] = aux[i++];</div><div class="line">				else</div><div class="line">					objArray[k] = aux[j--];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;快速排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 快速排序</div><div class="line"> * @param a</div><div class="line"> * @param low 开始位置</div><div class="line"> * @param high 结束位置</div><div class="line"> */</div><div class="line">public void quickSort(int[] a,int low,int high)&#123;</div><div class="line">       int start = low;</div><div class="line">       int end = high;</div><div class="line">       int key = a[low];</div><div class="line">       </div><div class="line">       </div><div class="line">       while(end&gt;start)&#123;</div><div class="line">           //从后往前比较</div><div class="line">           //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</div><div class="line">           while(end&gt;start&amp;&amp;a[end]&gt;=key) </div><div class="line">               end--;</div><div class="line">           if(a[end]&lt;=key)&#123;</div><div class="line">               int temp = a[end];</div><div class="line">               a[end] = a[start];</div><div class="line">               a[start] = temp;</div><div class="line">           &#125;</div><div class="line">           //从前往后比较</div><div class="line">           //如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</div><div class="line">           while(end&gt;start&amp;&amp;a[start]&lt;=key)</div><div class="line">              start++;</div><div class="line">           if(a[start]&gt;=key)&#123;</div><div class="line">               int temp = a[start];</div><div class="line">               a[start] = a[end];</div><div class="line">               a[end] = temp;</div><div class="line">           &#125;</div><div class="line">       //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小</div><div class="line">       //右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</div><div class="line">       &#125;</div><div class="line">       //递归</div><div class="line">       if(start&gt;low) quickSort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1</div><div class="line">       if(end&lt;high) quickSort(a,end+1,high);//右边序列。从关键值索引+1到最后一个</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
</div><div class="tags"></div><div class="post-nav"><a href="/2018/01/17/search/" class="pre">算法：查找学习笔记</a><a href="/2017/08/15/myCollection/" class="next">我的收藏</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://hujiachen822.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Hujiachen's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>